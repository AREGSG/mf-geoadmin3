From f1b30a700355933f98ae191b33555455a9f2f235 Mon Sep 17 00:00:00 2001
From: Olivier Terral <olivier.terral@swisstopo.ch>
Date: Fri, 8 Nov 2013 13:29:32 +0100
Subject: [PATCH] MSPointerEvents triggers touch or mouse  events depends on
 pointertype

---
 src/ol/mapbrowserevent.js |   70 +++++++++++++++++++--------------------------
 1 file changed, 29 insertions(+), 41 deletions(-)

diff --git a/src/ol/mapbrowserevent.js b/src/ol/mapbrowserevent.js
index e27ca0e..74f858a 100644
--- a/src/ol/mapbrowserevent.js
+++ b/src/ol/mapbrowserevent.js
@@ -253,7 +253,8 @@ ol.MapBrowserEventHandler.prototype.handleMouseUp_ = function(browserEvent) {
  * @private
  */
 ol.MapBrowserEventHandler.prototype.handleMouseDown_ = function(browserEvent) {
-  if (!goog.isNull(this.pointerdownListenerKey_)) {
+  if (browserEvent.type === goog.events.EventType.MOUSEDOWN &&
+      !goog.isNull(this.pointerdownListenerKey_)) {
     // mouse device detected - unregister the pointerdown and touchstart
     // listeners
     goog.events.unlistenByKey(this.pointerdownListenerKey_);
@@ -269,12 +270,16 @@ ol.MapBrowserEventHandler.prototype.handleMouseDown_ = function(browserEvent) {
   this.dispatchEvent(newEvent);
   this.down_ = browserEvent;
   this.dragged_ = false;
-  this.dragListenerKeys_ = [
-    goog.events.listen(goog.global.document, goog.events.EventType.MOUSEMOVE,
-        this.handleMouseMove_, false, this),
-    goog.events.listen(goog.global.document, goog.events.EventType.MOUSEUP,
-        this.handleMouseUp_, false, this)
-  ];
+
+  if (browserEvent.type === goog.events.EventType.MOUSEDOWN) {
+    this.dragListenerKeys_ = [
+      goog.events.listen(goog.global.document, goog.events.EventType.MOUSEMOVE,
+          this.handleMouseMove_, false, this),
+      goog.events.listen(goog.global.document, goog.events.EventType.MOUSEUP,
+          this.handleMouseUp_, false, this)
+    ];
+  }
+
   // prevent browser image dragging with the dom renderer
   browserEvent.preventDefault();
 };
@@ -315,12 +320,12 @@ ol.MapBrowserEventHandler.prototype.handlePointerDown_ =
     this.touchstartListenerKey_ = null;
   }
 
-  var newEvent = new ol.MapBrowserEvent(
-      ol.MapBrowserEvent.EventType.TOUCHSTART, this.map_, browserEvent);
-  this.dispatchEvent(newEvent);
+  if (browserEvent.getBrowserEvent().pointerType === 4) {
+    this.handleMouseDown_(browserEvent);
+  } else {
+    this.handleTouchStart_(browserEvent);
+  }
 
-  this.down_ = browserEvent;
-  this.dragged_ = false;
   this.dragListenerKeys_ = [
     goog.events.listen(goog.global.document,
         goog.events.EventType.MSPOINTERMOVE,
@@ -328,10 +333,6 @@ ol.MapBrowserEventHandler.prototype.handlePointerDown_ =
     goog.events.listen(goog.global.document, goog.events.EventType.MSPOINTERUP,
         this.handlePointerUp_, false, this)
   ];
-
-  // FIXME check if/when this is necessary
-  // prevent context menu
-  browserEvent.preventDefault();
 };
 
 
@@ -341,17 +342,10 @@ ol.MapBrowserEventHandler.prototype.handlePointerDown_ =
  */
 ol.MapBrowserEventHandler.prototype.handlePointerMove_ =
     function(browserEvent) {
-  // Fix IE10 on windows Surface : When you tap the tablet, it triggers
-  // multiple pointermove events between pointerdown and pointerup with
-  // the exact same coordinates of the pointerdown event. To avoid a
-  // 'false' touchmove event to be dispatched , we test if the pointer
-  // effectively moved.
-  if (browserEvent.clientX != this.down_.clientX ||
-      browserEvent.clientY != this.down_.clientY) {
-    this.dragged_ = true;
-    var newEvent = new ol.MapBrowserEvent(
-        ol.MapBrowserEvent.EventType.TOUCHMOVE, this.map_, browserEvent);
-    this.dispatchEvent(newEvent);
+  if (browserEvent.getBrowserEvent().pointerType === 4) {
+    this.handleMouseMove_(browserEvent);
+  } else {
+    this.handleTouchMove_(browserEvent);
   }
 };
 
@@ -361,18 +355,10 @@ ol.MapBrowserEventHandler.prototype.handlePointerMove_ =
  * @private
  */
 ol.MapBrowserEventHandler.prototype.handlePointerUp_ = function(browserEvent) {
-  var newEvent = new ol.MapBrowserEvent(
-      ol.MapBrowserEvent.EventType.TOUCHEND, this.map_, browserEvent);
-  this.dispatchEvent(newEvent);
-  goog.array.forEach(this.dragListenerKeys_, goog.events.unlistenByKey);
-
-  // We emulate click event on left mouse button click, touch contact, and pen
-  // contact. isMouseActionButton returns true in these cases (evt.button is set
-  // to 0).
-  // See http://www.w3.org/TR/pointerevents/#button-states .
-  if (!this.dragged_ && browserEvent.isMouseActionButton()) {
-    goog.asserts.assert(!goog.isNull(this.down_));
-    this.emulateClick_(this.down_);
+  if (browserEvent.getBrowserEvent().pointerType === 4) {
+    this.handleMouseUp_(browserEvent);
+  } else {
+    this.handleTouchEnd_(browserEvent);
   }
 };
 
@@ -382,7 +368,8 @@ ol.MapBrowserEventHandler.prototype.handlePointerUp_ = function(browserEvent) {
  * @private
  */
 ol.MapBrowserEventHandler.prototype.handleTouchStart_ = function(browserEvent) {
-  if (!goog.isNull(this.mousedownListenerKey_)) {
+  if (browserEvent.type === goog.events.EventType.TOUCHSTART &&
+      !goog.isNull(this.mousedownListenerKey_)) {
     // touch device detected - unregister the mousedown and pointerdown
     // listeners
     goog.events.unlistenByKey(this.mousedownListenerKey_);
@@ -400,7 +387,8 @@ ol.MapBrowserEventHandler.prototype.handleTouchStart_ = function(browserEvent) {
   this.down_ = browserEvent;
   this.dragged_ = false;
 
-  if (goog.isNull(this.dragListenerKeys_)) {
+  if (browserEvent.type === goog.events.EventType.TOUCHSTART &&
+     goog.isNull(this.dragListenerKeys_)) {
     this.dragListenerKeys_ = [
       goog.events.listen(goog.global.document, goog.events.EventType.TOUCHMOVE,
           this.handleTouchMove_, false, this),
-- 
1.7.10.4

